{"version": 2, "width": 132, "height": 40, "timestamp": 1702339389, "idle_time_limit": 1.0, "env": {"SHELL": "smallshell", "TERM": "xterm-256color"}, "title": "11_list_drivers"}
[0.003779, "o", "+ INFO\r\n"]
[0.004808, "o", "⦁ Available drivers are easy to find with the --list-drivers option.\r\n\r\n"]
[0.004947, "o", "+ nb5 --list-drivers\r\n"]
[2.105864, "o", "tcpclient\r\ntcpserver\r\nmongodb\r\nstdout\r\ndiag\r\ndynamodb\r\ncql\r\n"]
[2.106015, "o", "cqld4\r\nhttp\r\npulsar\r\ns4j\r\nkafka\r\namqp\r\njdbc\r\npinecone\r\n"]
[2.301715, "o", "+ INFO\r\n"]
[2.303326, "o", "⦁ You can load help for any given driver with \r\n  nb5 help <driver> \r\n\r\n"]
[2.303588, "o", "+ nb5 help http\r\n"]
[4.642543, "o", "# http\r\n\r\nThis driver allows you to make http requests using the native HTTP client\r\nthat is bundled with the JVM. It supports free-form construction of\r\nrequests.\r\n\r\nYou specify what a request looks like by providing a set of request\r\nparameters. They can be in either literal (static) form with no dynamic\r\ndata binding, or they can each be in a string template form that draws\r\nfrom data bindings. Each cycle, a request is assembled from these\r\nparameters and executed.\r\n\r\n## Example Statements\r\n\r\nThe simplest possible statement form looks like this:\r\n\r\n```yaml\r\nop: http://google.com/\r\n```\r\n\r\nOr, you can have a list:\r\n\r\n```yaml\r\n# A list of statements\r\nops:\r\n - http://google.com/\r\n - http://amazon.com/\r\n```\r\n\r\nOr you can template the values used in the URI, and even add ratios:\r\n\r\n```yaml\r\n# A list of named statements with variable fields and specific ratios:\r\nops:\r\n    - s1: http://google.com/search?query={query}\r\n      ratio: 3\r\n    - s2: https://www.amazon.com/s?k={query}\r\n      ratio: 2\r\nbindings:\r\n    query: >\r\n        WeightedStrings('function generator;backup generator;static generator');\r\n        UrlEncode();\r\n```\r\n\r\nYou can even make a detailed request with custom headers and result\r\nverification conditions:\r\n\r\n```yaml\r\n# Require that the result be status code 200-299 match regex \"OK, account id is .*\" in the body\r\nops:\r\n    - get-from-google:\r\n      method: GET\r\n      uri: \"https://google.com/\"\r\n      version: \"HTTP/1.1\"\r\n      Content-Type: \"application/json\"\r\n      ok-status: \"2[0-9][0-9]\"\r\n      ok-body: \"^(OK, account id is .*)$\"\r\n```\r\n\r\nFor those familiar with what an HTTP request looks like on the wire, the\r\nformat below may be familiar. This isn't actually the content that is\r\nsubmitted, but it is recognized as a valid way to express the request\r\nparameters in a familiar and condensed form. A custom config parser makes\r\nthis form available fo rhose who want to emulate a well-known pattern:\r\n\r\n```yaml\r\nops:\r\n    - s1: |\r\n          GET https://google.com/ HTTP/1.1\r\n          Content-Type: application/json\r\n      ok-status: 2[0-9][0-9]\r\n      ok-body: ^(OK, account id is.*)$\r\n```\r\n\r\nOf course, in the above form, the response validators are still separate\r\nparameters.\r\n\r\n## Bindings\r\n\r\nAll request fields can be made dynamic with binding functions. To make a\r\nrequest that has all dynamic fields, you can do something like this:\r\n\r\n```yaml\r\nops:\r\n    - s1: |\r\n          {method} {scheme}://{host}:{port}/{path}?{query} {version}\r\n          Content-Type: {content_type}\r\n          Token: {mybearertoken}\r\n\r\n          {body}\r\n```\r\n\r\nThe above example is in the inline request form. It is parsed and\r\ninterpreted internally as if you had configured your op template like\r\nthis:\r\n\r\n```yaml\r\nops:\r\n    - method: { method }\r\n      uri: { scheme }://{host}:{port}/{path}?{query}\r\n      version: { version }\r\n      \"Content-Type\": { content_type }\r\n      \"Token\": { mybearertoken }\r\n      body: { body }\r\n```\r\n\r\nThe above two examples are semantically identical, only the format is\r\ndifferent. Notice that the expansion of the URI is still captured in a\r\nfield called uri, with all the dynamic pieces stitched together in the\r\nvalue. You can't use arbitrary request fields. Every request field must\r\nfrom (method, uri, version, body, ok-status, ok-body) or otherwise be\r\ncapitalized to signify an HTTP header.\r\n\r\nThe HTTP RFCs do not require headers to be capitalized, but they are\r\ncapitalized ubiquitously in practice, so we follow that convention here\r\nfor clarity. Headers are in-fact case-insensitive, so any issues created\r\nby this indicate a non-conformant server/application implementation.\r\n\r\nFor URIs which are fully static (There are no dynamic fields, request\r\ngeneration will be much faster, since the request is fully built and\r\ncached at startup.\r\n\r\n## Request Fields\r\n\r\nAt a minimum, a **URI** must be provided. This is enough to build a\r\nrequest with. All other request fields are optional and have reasonable\r\ndefaults:\r\n\r\n- **uri** - This is the URI that you might put into the URL bar of your\r\n  browser. There is no default.\r\n  Example: `https://en.wikipedia.org/wiki/Leonhard_Euler`\r\n  If the uri contains a question mark '?' as a query delimiter, then all\r\n  embedded sections which are contained within `URLENCODE[[` ... `]]`\r\n  sections are preprocessed by the HTTP driver. This allows you to keep\r\n  your test data in a recognizable form. This is done at startup, so there\r\n  is no cost during the test run. As an added convenience, binding points\r\n  which are within the encoded block will be preserved, so\r\n  both `https://en.wikipedia.org/URLENCODE[[wiki/]]{topic}` and\r\n  `https://en.wikipedia.org/URLENCODE[[wiki/{topic}]]` will yield the same\r\n  configuration. For a terser form, you can use `E[[...]]`. You must also\r\n  ensure that the values that are inserted at binding points are produced\r\n  in a valid form for a URI. You can use the `URLEncode()`"]
[4.642771, "o", "\r\n  binding function where needed to achieve this.\r\n  *NOTE*, If you are using dynamic values for the uri field, and\r\n  a test value for cycle 0 includes neither `URLENCODE[[` nor `E[]`,\r\n  then it is skipped. You can override this with `enable_urlencode: true`.\r\n- **method** - An optional request method. If not provided, \"GET\" is\r\n  assumed. Any method name will work here, even custom ones that are\r\n  specific to a given target system. No validation is done for standard\r\n  method names, as there is no way to know what method names may be valid.\r\n- **version** - The HTTP version to use. If this value is not provided,\r\n  the default version for the Java HttpClient is used. If it is provided,\r\n  it must be one of 'HTTP/1.1' or 'HTTP/2.0'.\r\n- **body** - The content of the request body, for methods which support\r\n  it.\r\n- **ok-status** - An optional set of rules to verify that a response is\r\n  valid. This is a simple comma or space separated list of integer status\r\n  codes or a pattern which is used as a regex against the string form of a\r\n  status code. If any characters other than digits spaces and commas are\r\n  found in this value, then it is taken as a regex. If this is not\r\n  provided, then any status code which is >=200 and <300 is considered\r\n  valid.\r\n- **ok-body** - An optional regex pattern which will be applied to the\r\n  body to verify that it is a valid response. If this is not provided,\r\n  then content bodies are read, but any content is considered valid.\r\n- **result-type** - If provided, you can specify `none`, `string`, or `json_element`.\r\n  By default, this is set to `none` and the http op will not produce a result type.\r\n  If you use string, then the raw body is returned, and if you use json_element,\r\n  then the body is presumed to be valid JSON, and it is parsed and returned as\r\n  a JsonElement.\r\n\r\nAny other statement parameter which is capitalized is taken as a request\r\nheader. If additional fields are provided which are not included in the\r\nabove list, or which are not capitalized, then an error is thrown.\r\n\r\n## Error Handling & Retries\r\n\r\nBy default, a request which encounters an exception is retried up to 10\r\ntimes. If you want to change this, set another value to the\r\n`retries=` activity parameters.\r\n\r\nPresently, no determination is made about whether an errored\r\nresponse *should* be retryable, but it is possible to configure this if\r\nyou have a specific exception type that indicates a retryable operation.\r\n\r\nThe HTTP driver is the first NB driver to include a completely\r\nconfigurable error handler chain. This is explained in the\r\n`error-handlers` topic. By default, the HTTP activity's error handler is\r\nwired to stop the activity for any error encountered.\r\n\r\n## SSL Support\r\n\r\nSSL should work for any basic client request that doesn't need custom SSL\r\nconfiguration. If needed, more configurable SSL support will be added.\r\n\r\n## Client Behavior\r\n\r\n### TCP Sessions & Clients\r\n\r\nClient instances are created for each unique `space` value. NoSQLBench\r\nprovides a way for all driver adapters to instance native clients according\r\nto a data from a binding. This is standardized under the op template parameter\r\n`space`, which is wired by default to the static value `default`. This means\r\nthat each activity that uses the http driver shares a client instance across\r\nall threads by default. If you want to have a new http client per-thread,\r\nsimply add a binding for `space: ThreadNumToInteger()` and reference it in\r\nan op template like `space: {space}`, OR use an inline op field in your op\r\ntemplate like `space: {(ThreadNumToInteger())}`.\r\n\r\nYou can use any binding function you want for the space op field. However,\r\nif you were to assign it something like \"space: {(Identity()}\" you would\r\nnot have a good result, as you would be spinning up and caching a new http client\r\ninstance for every single cycle.\r\n\r\n### Chunked encoding and web sockets\r\n\r\nPresently, this driver only does basic request-response style requests.\r\nThus, adding headers which take TCP socket control away from the\r\nHttpClient will likely yield inconsistent (or undefined)\r\nresults. Support may be added for long-lived connections in a future\r\nrelease. However, chunked encoding responses are supported, although they\r\nwill be received fully before being processed further. Connecting to a long-lived\r\nconnection that streams chunked encoding responses indefinitely will have\r\nundefined results.\r\n\r\n## HTTP Activity Parameters\r\n\r\n- **follow_redirects** - default: normal - One of never, always, or\r\n  normal. Normal redirects are those which do not redirect from HTTPS to\r\n  HTTP.\r\n\r\n- **diagnostics** - default: none - synonym: **diag**\r\n  example: `diag=brief,1000` - print diagnostics for every 1000th cycle,\r\n  including only brief details as explained below.\r\n\r\n  This setting is a selector for what level of verbosity you will get on\r\n  the console. If you set this to `diag=all`, you'll get every request and\r\n  response logged to console. This is only for verifying that a test is\r\n  configured and to spot check services before running higher scale tests.\r\n\r\n  All the data shown in diagnostics is post-hoc, directly from the\r\n  response provided by the internal HTTP client in the Java runtime.\r\n\r\n  If you want finer control over how much information diagnostics\r\n  provides, you can specify a comma separated list of the below.\r\n\r\n    - headers - show headers\r\n    - stats - show basic stats of each request\r\n    - data - show all of each response body this setting\r\n    - data10 - show only the first 10 characters of each response body\r\n      this setting supersedes `data`\r\n    - data100 - show only the first 100 characters of each response body\r\n      this setting supersedes `data10`\r\n    - data1000 - show only the first 1000 characters of each response body\r\n      this setting supersedes `data100`\r\n    - redirects - show details for interstitial request which are made\r\n      when the client follows a redirect directive like a `location`\r\n      header\r\n    - requests - show details for requests\r\n    - responses - show details for responses\r\n    - codes - shows explanatory details (high-level) of http response status codes\r\n    - brief - Show headers, stats, requests, responses, and 10 characters\r\n    - all - Show everything, including full payloads and redirects\r\n    - a modulo - any number, like 3000 - causes the diagnostics to be\r\n      reported only on this cycle modulo. If you set `diag=300,brief`\r\n      then you will get the brief diagnostic output for every 300th\r\n      response.\r\n\r\n  The requests, responses, and redirects settings work in combination.\r\n  For example, if you specify responses, and redirect, but not requests,\r\n  then you will only see the response portion of all calls made by the\r\n  client. All available filters layer together in this way.\r\n\r\n- **timeout** - default: forever - Sets the timeout of each request in\r\n  milliseconds.\r\n\r\n"]
